/*
 * Copyright (C) 2014 Lymia Aluysia <lymiahugs@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.lymiahugs.civ5.mod2dlc

import java.io.{PrintStream, FileOutputStream, File}
import scala.xml.XML
import java.util.UUID
import java.nio.file.Files
import com.lymiahugs.civ5.mod2dlc.data.LuaFrag

class TranslateMod(log_callback: String => Unit) {
  def listFiles(file: File): Seq[File] =
    if(file.isFile) Seq(file)
    else file.listFiles().flatMap(listFiles _)

  def log(format: String, args: Any*) =
    log_callback(format.format(args: _*))

  def readFile(file: File) =
    scala.io.Source.fromFile(file).mkString
  def writeFile(file: File, data: String, source: String = "") = {
    log("Writing%s to %s", source, file.getCanonicalPath)
    new PrintStream(new FileOutputStream(file)).print(data)
  }
  def copy(source: File, target: File) = {
    log("Copying %s to %s", source.getCanonicalPath, target.getCanonicalPath)
    Files.copy(source.toPath, target.toPath)
  }

  def translateMod(modSource: File, target: File) =
    try {
      if(!target.exists) target.mkdirs()

      val sourceFiles = listFiles(modSource)
      val modinfoFile = sourceFiles.find(_.getName.endsWith(".modinfo")).
        getOrElse(sys.error("No .modinfo found!"))

      val modinfo = (XML.loadFile(modinfoFile) \ "ModInfo").head
      val uuid = UUID.fromString((modinfo \ "@id").text)
      val uuid_string = uuid.toString.filter(_!='-').toUpperCase

      val luaFiles = sourceFiles.filter(_.getName.endsWith(".lua"))
      val luaDir   = new File(target, "Gameplay/Lua")
      luaDir.mkdirs()

      val luaFilePrefix = "_mod2dlc_"+uuid_string+"_"
      // we add a small stub to the top of all the Lua functions so it loads the right thing
      // in includes.
      val header = LuaFrag.includeOverrideHeader(luaFilePrefix)
      for(luaFile <- luaFiles) {
        val newName = luaFilePrefix+luaFile.getName
        writeFile(new File(luaDir, newName), header+readFile(luaFile))
      }

      // Write XML file
      val version = (modinfo \ "@version").text.toInt
      val modName = (modinfo \ "Name").text

      def generated_civ5pkg = <Civ5Pkg>
        <UUID>{"{"+uuid+"}"}</UUID>
        <SteamApp>99999</SteamApp>
        <Version>{version.toString}</Version>
        <Ownership>FREE</Ownership>
        <PTags>
          <Tag>Version</Tag>
          <Tag>Ownership</Tag>
        </PTags>
        <Key>{DLCKey.key(uuid, Seq(99999), version, "FREE")}</Key>

        <Name>
          <Value language="en_US">{modName}</Value>
        </Name>
        <Description>
          <Value language="en_US">{modName}</Value>
        </Description>

        <Gameplay>
          <Directory>Gameplay</Directory>
        </Gameplay>
      </Civ5Pkg>
      writeFile(new File(target, modinfoFile.getName.replace(".modinfo", "")+".civ5pkg"),
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"+
        "<!-- Generated by Mod2Dlc by Lymia -->\n"+
        generated_civ5pkg.toString(), " mod description")
    } catch {
      case t: Throwable =>
        t.printStackTrace()
        log("Error encountered: "+t.getClass.getCanonicalName+": "+t.getMessage)
        throw t
    }
}
